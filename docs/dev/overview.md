# Development Overview
This file documents the purpose and architecture of programs contained in this repository.
It is meant to serve as a brief technical overview of the project's structure.

## Purpose
Provide linters that complement [`pylint-odoo`](https://github.com/OCA/pylint-odoo). `pylint-odoo` is focused on
checking Python source code, which means linters in this project focus solely on the following types of files:

* csv
* po
* xml

As the name of the repository implies, all linters in this project must be compatible with
[`pre-commit`](https://pre-commit.com/). This means **all linters must comply with the following points:

* provide an entrypoint in the form of an executable which takes (at least) filenames as arguments
* nonzero exit on failure

A linter is considered to have failed once it emits a message.

## Nomenclature
* Linter: An executable (entry point) which runs checks and emits messages.
* Check: A routine inside a linter, verifies the source code conforms to a certain rule (or rules).
* Message: **Generated by checks** when a rule is not met. **Emitted by linters**.

Why is this last point important? Checks must be self-contained units which perform a single task: verify the source
code conforms to the rule it checks for. This improves testability. Printing out messages (emitting) is a completely
different task.

## Checks
Checks are run by linters. The nature of checks can be divided in two categories:

* Stateful
* Stateless

### Stateful Checks
These are checks that depend on other files. **The check must process all its dependencies everytime it runs**. Most
times these dependencies consist of all files of the same type inside an
[Odoo module](https://www.odoo.com/documentation/16.0/developer/howtos/backend.html). An example of a stateful
check is `xml-duplicate-record-id`.

This check must read all `<record>` tags inside a module and verify none of them share the
same id (`<record id="...">`), `<record>` tags are found in **xml** files, so this check **must read all xml files in
a module**.

### Stateless Checks
These checks have no dependencies. They only need to process the very file they are checking. An example would be
`xml-deprecated-node`. This check ensures there are no `<data>` tags in xml files.

## Messages
Messages are generated by checks, but emitted by linters. They alert the user about failure to meet one of the
rules verified by checks. They are a standardized in a dataclass. **All compliant checks must only generate
messages in their standardized format (see Architecture Specs).

## Linters
Linters are programs executed by the user to run various checks. They are separated based on the types of checks they
run. **Linters must contain only one type of check (stateful or stateless).**

> **Warning**
> Running stateless and stateful checks inside the same linter will nullify two features of `pre-commit`:
> 1. performing  checks only on files which have been modified
> 2. parallelization (files are distributed between various instances of the linter)

Linters are composed of five elements:

* **Frontend**: Command line executable. **In charge of parsing all user input**. User input not only consists of
command line arguments, but also environment variables and configuration files. Said configuration files may not be
explicitly stated by the user and may reside in default locations. It needs to normalize all user input into a common
format for the next component, the *scheduler*.
* **Scheduler**: Gathers all checks and runs the *necessary* checks in an orderly manner. Note the word
*necessary*. Certain messages may be disabled. The scheduler must detect these
cases and stop the checks that generate said messages from running.
* **Checks**: Self contained function which takes a predefined list of arguments and if necessary generates messages.
* **Message Stack**: Stores all messages generated during the execution of checks.
* **Printer**: Reads messages from the message stack and generates the corresponding output. Generally in the form
of text to `stdout`.

```mermaid
flowchart TD;
  start([Executable is run]) --> frontend[/Parse user's arguments. Read environment variables and config files/]

  frontend --> frontendProc(Normalize user input into standard configuration)
  frontendProc --> scheduler(Start Scheduler with normalized config)

  scheduler --> check(Run Check)
  check --> checkIf{Any more checks?}
  checkIf -->|Yes| check

  checkIf -->|No| msgIf{Are there any <br> messages in the <br> Message Stack?}
  msgIf -->|Yes| printer[/Show messages to user/]
  msgIf -->|No| zeroExit([Exit with return code = 0])
  printer --> nonZeroExit([Exit with return code != 0])
```

## Architecture Specs
Based on the components and their definitions mentioned below the following architecture is used. It tries to be
as standard and strict as possible in order to streamline development and reduce the creation of
technical debt, but provides means to customize behavior if necessary (for any edge cases).

### Frontend
The main task for the frontend is parsing user's configuration and normalizing into a common format for the Scheduler.
To enforce the format, it has been declared as a dataclass (`SchedulerConfiguration`).

#### Scheduler Configuration Requirements
In the case of stateful linters, `filenames` shall consist solely of `__manifest__.py` files. The manifest file
states all source code files (outside of Python) and lets the scheduler calculate any dependencies which need to be
checked.

For stateless linters, `filenames` consists of all files to be checked. Ideally these will only be those changed
by the current commit. The frontend does not perform any processing on the original `filenames` generated by
`pre-commit`.

### Scheduler and Lifecycle
As stated before, the scheduler must run all necessary checks. Besides running checks it also needs to run
the following "Lifecycle methods":

* `check_loop` - Runs all checks in the linter against a file.
* `on_global_open` - Runs just before checks start being run.
* `on_global_close` - Runs after all checks have run. The scheduler will yield control of the program after calling this method.
* `on_open` - Runs before a check loop starts.
* `on_close` - Runs after a check loop. The next check loop (if any) will be run after this

### Message Stack
Stores all messages generated by checks. Must implement (at least) the following method:

* `store_message` - Stores a new message into the stack.

### Printer
Produces output for the user to see. This output should contain all messages generated by checks. Alternatively,
the user can choose to display messages that can be generated by the linter instead of linting files. The printer
must produce said output too (message descriptions).

## pre-commit Integration
[pre-commit](https://pre-commit.com/) is a tool that integrates with Git to automatically run checks before
committing changes. It uses Git Hooks to accomplish this. Two important features are `require_serial` and the ability
to run lints on only files that have been changed.

`require_serial` lets linters run in parallel processes. This speeds up the linting process and is generally a nice
thing to have. Linting the minimum amount of files needed (only those that have changed) is also a great benefit as it
reduces CPU usage/time (and saves money).

### Stateless Linters
All compliant Stateless Linters can and should run (if possible) as parallel processes. As of
writing this, [it is this way by default](), so no extra configuration needs to be performed. They should also lint
only files of their type that have been modified. This is also the default.

A sample configuration for this type of linter could be:
```yaml
# .pre-commit-hooks.yaml
- id: stateless-csv-checker
  name: check csv files
  entry: csv-checker
  types: [csv]
```

### Stateful Linters
Stateful Linters can't run in parallel processes, since they need the same context in order to detect stuff like
duplicate IDs. This means their entry in `.pre-commit-hooks.yaml` must contain `require_serial: true`.

They are only needed when files of their type (csv, po, xml) are changed. For example, there is no sense
in running an XML Linter (and looking for duplicated ids) if only .po or .csv files were changed.
Using the same example, they do have to run if just a single XML file has been changed, and they need to run on
all XML files *in the module*.

Emphasis is on *module*, if `views.xml` from the module `sale_management` is changed, there is no need to check files
in other modules. Context is limited to the module in this case. A sample configuration for this type of
linter would be:

```yaml
# .pre-commit-hooks.yaml
- id: stateful-xml-checker
  name: check xml files
  require_serial: true
  entry: xml-checker
  types: [xml]
```

Following the example before, if `views.xml` is changed, `pre-commit` will pass it to the executable as part of
the `filenames` argument. Initially the stateful linter will only have a xml file in its filenames
(it needs all xml files in said module). This is where the flexibility provided by separating concerns comes into
place.

The Frontend receives `views.xml` as the only file. This Frontend has been written for Stateful Linters, so it knows
it needs all XML files. Therefore, it finds the module `views.xml` belongs to, reads it `__manifest__.py` and
generates a `SchedulerConfiguration` whose `filenames` contain all the module's XML files it found. This configuration
is passed to the scheduler and all checks run as expected.
