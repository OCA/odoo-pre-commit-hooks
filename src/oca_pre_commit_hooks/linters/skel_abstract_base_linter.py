from abc import ABCMeta, abstractmethod
from argparse import ArgumentParser
from os import environ
from typing import Mapping, Sequence, Set

from oca_pre_commit_hooks.linters.message import Message
from oca_pre_commit_hooks.linters.scheduler_configuration import SchedulerConfiguration


class SkelAbstractLinter(metaclass=ABCMeta):
    # List of messages this linter can produce
    _messages: Mapping[str, str] = None

    config_name = ".oca_hooks.cfg"
    msg_ctrl = "MESSAGES_CONTROL"
    enable_env_var = "OCA_HOOKS_ENABLE"
    disable_env_var = "OCA_HOOKS_DISABLE"
    manifest_names: Sequence[str] = ["__manifest__.py", "__openerp__.py"]

    def __init__(self):
        super().__init__()
        self.parser = ArgumentParser()

        self.parser.add_argument("filenames", nargs="*", help="Files to run checks on")
        self.parser.add_argument(
            "--enable",
            type=self.parse_csv,
            default=self._default_env_csv(self.enable_env_var),
            help="Comma separated list of messages to enable. Messages not in this list will be disabled",
        )
        self.parser.add_argument(
            "--disable",
            type=self.parse_csv,
            default=self._default_env_csv(self.disable_env_var),
            help="Comma separated list of messages to disable. Messages not in this list will be enabled",
        )
        self.parser.add_argument(
            "--list-msgs", default=False, action="store_true", help="Print all messages the linter can emit and exit"
        )
        self.parser.add_argument(
            "--zero-exit", default=False, action="store_true", help="Zero value exit even if messages were emitted"
        )

    @staticmethod
    def parse_csv(csv: str) -> Set[str]:
        return set(map(str.strip, csv.split(",")))

    @staticmethod
    def _default_env_csv(env_var) -> Set[str]:
        if environ.get(env_var, False):
            return SkelAbstractLinter.parse_csv(environ[env_var])

        return set()

    # Lifecycle
    def on_global_open(self):
        pass

    def on_global_close(self):
        pass

    def on_open(self):
        pass

    def on_close(self):
        pass

    @abstractmethod
    def get_exit_status(self, zero_exit: bool = False) -> int:
        pass

    def run(self, argv: Sequence[str]) -> int:
        """Entrypoint (this runs when  the user calls the executable)."""
        # Frontend is called
        config = self.generate_config(argv)
        if config.list_msgs:
            self.print_message_descriptions()
            return 0

        # Scheduler starts with a call to _on_global_open
        self.on_global_open()
        # Files get linted. A check loop is run per file.
        for file in config.filenames:
            self.perform_check_run(config, file)
        # Scheduler ends with a call to _on_global_close
        self.on_global_close()

        self.print_generated_messages()

        return self.get_exit_status(config.zero_exit)

    # Frontend
    @abstractmethod
    def generate_config(self, argv: Sequence[str]) -> SchedulerConfiguration:
        pass

    # Scheduler
    @abstractmethod
    def _check_loop(self, config: SchedulerConfiguration, file: str):
        pass

    def perform_check_run(self, config: SchedulerConfiguration, file: str):
        self.on_open()
        self._check_loop(config, file)
        self.on_close()

    # Message Stack
    def add_message(self, message: Message):
        if message.key not in self._messages:
            raise ValueError(f"Message type {message.key} is not generated by this linter.")

        self._store_message(message)

    @abstractmethod
    def _store_message(self, message: Message):
        pass

    # Printer
    @abstractmethod
    def print_generated_messages(self):
        pass

    @abstractmethod
    def print_message_descriptions(self):
        pass
