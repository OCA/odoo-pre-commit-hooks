import inspect
from abc import ABC
from typing import List, MutableMapping, Sequence, Set, Union

from oca_pre_commit_hooks.linters.message import Message
from oca_pre_commit_hooks.linters.scheduler_configuration import SchedulerConfiguration
from oca_pre_commit_hooks.linters.skel_abstract_base_linter import SkelAbstractLinter


class AbstractBaseLinter(SkelAbstractLinter, ABC):
    def __init__(self):
        super().__init__()
        self.generated_messages: MutableMapping[str, List[Message]] = {}

    # Abstract Methods
    def get_exit_status(self, zero_exit: bool = False) -> int:
        if zero_exit:
            return 0

        if len(self.generated_messages.keys()) > 0:
            return -1

        return 0

    def generate_config(self, argv: Union[Sequence[str], None] = None) -> SchedulerConfiguration:
        args = self.parser.parse_args(argv)
        return SchedulerConfiguration(args.filenames, args.enable, args.disable, args.list_msgs, args.zero_exit)

    def _store_message(self, message: Message):
        if message.key in self.generated_messages:
            self.generated_messages[message.key].append(message)
        else:
            self.generated_messages[message.key] = [message]

    def print_generated_messages(self):
        for message_key, messages in self.generated_messages.items():
            print(f"****{message_key}****")
            for message in messages:
                msg_line = message.line if message.line > 0 else ""
                msg_col = message.column if message.column > 0 else ""
                print(f"{message.file}:{msg_line}:{msg_col} -> {self._messages[message_key] % message.args}")

    def print_message_descriptions(self):
        for key, description in self._messages.items():
            print(f":{key}: {description}")

    # Extra functionality to easily gather and run tests
    def get_all_checks(self):
        checks = inspect.getmembers(
            self, predicate=lambda member: inspect.ismethod(member) and member.__name__.startswith("check")
        )

        return {check[1] for check in checks}

    def get_active_checks(self, enable: Union[Set[str], None] = None, disable: Union[Set[str], None] = None):
        """Return all active checks (methods) based on the enabled and disabled messages."""
        return {check for check in self.get_all_checks() if self._is_check_enabled(check, enable, disable)}

    @staticmethod
    def _get_check_messages(check):
        return getattr(check, "checks", set())

    def _is_check_enabled(self, check, enable: Union[Set[str], None] = None, disable: Union[Set[str], None] = None):
        """Whether a check or not is enabled, based on the disabled and enabled messages.
        Checks MUST NOT be confused with messages. Checks are python methods which can generate multiple types of
        messages. For example, a check can generate both 'csv-syntax-error' and 'csv-duplicate-record-id' and even
        if 'csv-duplicate-record-id' is disabled, the check will still need to run since it also generates
        'csv-syntax-error' messages.

        Messages generated by checks are gathered from the @utils.only_required_for_checks() decorator.
        """
        check_messages = self._get_check_messages(check)
        if disable:
            return not bool(check_messages & disable)
        if enable:
            return bool(check_messages.issubset(enable))

        return True
